МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ




ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмна інженерія»








ЗВІТ
з практичної роботи №1
з дисципліни «Аналіз та рефакторинг коду»
на тему «Правила оформлення програмного коду на Type Script»














Виконав:                                          Прийняла:
ст. гр. ПЗПІ-23-8                             Старший викладач каф. ПІ Сокорчук І. П.
Козлов С. О. 










Харків 2025
1.1 Історія змін


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	10.11.2025
	0.1
	Створено структуру звіту, додано розділи «Мета» та «Висновки».
	2
	10.11.2025
	0.1
	Додано розділ «Хід роботи» з аналізом Airbnb Style Guide.
	3
	10.11.2025
	0.1
	Оформлено приклади рефакторингу «до» та «після» у Додатку В.
	4
	10.11.2025
	0.1
	Додано Додатки А (хронометраж відео) та Б (слайди).
	



1.2 Мета роботи
Метою даної роботи є дослідження важливості конвенцій оформлення коду (code conventions) як основи для рефакторингу та підтримки програмних проєктів.


1.3 Хід роботи


1.3.1  Обґрунтування дослідження
Написання коду, який просто працює, є недостатнім для довгострокових проєктів. Поганий код, що не відповідає жодним стандартам, важко читати, підтримувати та масштабувати. Нові розробники можуть витрачати тижні на розуміння логіки проєкту, що збільшує витрати на розробку.
Конвенції коду вирішують цю проблему. Для глибокого аналізу було обрано Airbnb TypeScript Style Guide. Це один з найсуворіших та найпопулярніших стандартів у індустрії , який слугує чудовим прикладом того, як правила допомагають уникнути помилок.




1.3.2 Аналіз прикладів рефакторингу
На основі обраного стандарту було розглянуто декілька поширених кодових запахів та методи їх рефакторингу.
Проблема області видимості: var проти const/let
* Проблема: Використання ключового слова var зі "старого" JavaScript призводить до помилок. var має функціональну, а не блочну область видимості, що веде до випадкових перевизначень змінних.
* Рефакторинг (Рішення): Стандарт Airbnb вимагає використовувати const та let. const використовується за замовчуванням для значень, що не змінюються. let — лише для змінних, які будуть переприсвоєні. Це робить код передбачуваним та уникає помилок з областю видимості.
* Приклади коду наведені у Додатку В (В.1, В.2).
Проблема неявності: "Магічні числа"
* Проблема: Використання чисел у коді без пояснення їхньої суті (наприклад, if (user.role === 3)). Такі «магічні числа» роблять код незрозумілим та вкрай складним для підтримки, адже якщо число доведеться змінити, його потрібно шукати по всьому проєкту.
* Рефакторинг (Рішення): Винесення всіх «магічних чисел» у константи з описовими іменами (наприклад, const ADMIN_ROLE = 3;). Це робить код самодокументованим.
* Приклади коду наведені у Додатку В (В.3, В.4).
Проблема інтерфейсу: "Пастка булевих значень"
* Проблема: Створення функцій, які приймають декілька булевих аргументів (наприклад, createUser(name, true, false, true)). Неможливо зрозуміти, що означає true чи false без вивчення документації.
* Рефакторинг (Рішення): Замість набору аргументів функція має приймати один об'єкт налаштувань. Це дозволяє давати аргументам імена, робить їх порядок неважливим та покращує читабельність.
* Приклади коду наведені у Додатку В (В.5, В.6).
1.3.3 Архітектурний вплив та інструменти
Конвенції коду впливають не лише на синтаксис, але й на архітектуру. Стандарт Airbnb, подібно до фреймворку React, надає перевагу композиції над наслідуванням. Заборона глибоких ієрархій класів (class Admin extends User) на користь композиції (const user = new User()) робить систему більш гнучкою та модульною, що спрощує тестування.


Дотримання цих правил вручну неможливе. Тому ключову роль відіграє автоматизація:
* Лінтер (ESLint): Аналізує код та знаходить порушення стилю.
* Форматер (Prettier): Автоматично виправляє форматування (відступи, лапки).
* Файл конфігурації .eslintrc слугує законом проєкту, що визначає всі правила




1.4 Висновки
Було розглянуто концепцію «чистого коду» та виявлено, що конвенція коду – це не краса, а фундаментальний інструмент підтримки та масштабування проєкту.
Було проаналізовано конкретні приклади рефакторингу (магічні числа, var vs const, пастка булевих значень), що покращують читабельність та надійність коду.
Було виявлено, що правила стилю завжди прив'язані до конкретного проєкту (як Airbnb, Google чи Linux) і можуть визначати його архітектуру (наприклад, надаючи перевагу композиції над наслідуванням).
Отримано навички використання інструментів автоматизації (ESLint, Prettier) для статичного аналізу коду та примусового дотримання стандартів.


1.5 Використані джерела
1. ESLint: Find and fix problems in your JavaScript code. [Online]. Available: {https://eslint.org/}
2. Prettier: An opinionated code formatter. [Online]. Available: {https://prettier.io/}
3. ДСТУ 3008:2015. Інформація та документація. Звіти у сфері науки і техніки. Структура та правила оформлювання.




Додаток А
Відеозапис доповіді розміщено на платформі YouTube за посиланням:
https://youtu.be/ycY3yR5WSwM


Хронологічний опис відеозапису:
* 0:00 - Вступ
* 0:34 - Чому "поганий" код – це дорого і складно
* 1:03 - Чому ми аналізуємо саме Airbnb Style Guide
* 1:30 - Рефакторинг (Приклад 1): var проти const/let
* 2:41 - Рефакторинг (Приклад 2): "Магічні числа"
* 3:34 - Рефакторинг (Приклад 3): "Пастка" булевих значень
* 4:23 - Архітектура (Приклад 4): Композиція замість наслідування
* 4:59 - Автоматизація: Як змусити всіх дотримуватись правил (ESLint)
* 5:33 - Висновки: 4 головні думки (Код – це інструмент, а не "краса")




Додаток Б
Слайди презентації


  

Рисунок Б.1 — Титульний слайд: Аналіз рефакторингу на базі Style Guide
  

Рисунок Б.2 — Постановка проблеми: Складність читання та крива навчання


  

Рисунок Б.3 — Обґрунтування вибору кейсу: Airbnb Style Guide 
  

Рисунок Б.4 — Опис проблеми з var (Приклад 1) 


  

Рисунок Б.5 — Рішення: Рефакторинг з const та let (Приклад 1)


  

Рисунок Б.6 — Опис проблеми "магічних чисел" (Приклад 2) 


  

Рисунок Б.7 — Рішення: Винесення чисел у константи (Приклад 2) 
  

Рисунок Б.8 — Опис "пастки булевих значень" (Приклад 3) 


  

Рисунок Б.9 — Рішення: Рефакторинг з об'єктом налаштувань (Приклад 3)


  

Рисунок Б.10 — Архітектурний вплив: Композиція проти наслідування (Приклад 4)


  

Рисунок Б.11 — Інструменти автоматизації: ESLint та Prettier 
  

Рисунок Б.12 — Підсумкові висновки роботи




















































Додаток В
Програмний код
https://github.com/NureKozlovSerhii/ark-pzpi-23-8-kozlov-serhii/blob/main/Pract1/pzpi-23-8-kozlov-serhii-pract1/code-examples-code-conventions


В.1 Приклад коду до рефакторинґу (проблема var):
 1. console.log("--- Приклад 1 (ДО): var ---");
 2. (function () {
 3.   var name = "Ivan";
 4.   if (true) {
 5.     var name = "Petro"; // Змінна var не має блочної області видимості, тому відбувається перезапис
 6.   }
 7.   console.log(name); // Виведе "Petro", бо змінна одна й та сама в межах функції
 8. })(); // IIFE використано для ізоляції області видимості


В.2 Приклад коду після рефакторинґу (використання const):
 9. console.log("--- Приклад 1 (ПІСЛЯ): const ---");
10. (function () {
11.   const name = "Ivan";
12.   if (true) {
13.     const name = "Petro"; // Тут створюється нова змінна у власному блоці
14.   }
15.   console.log(name); // Виведе "Ivan", бо зовнішня змінна не змінювалась
16. })();


В.3 Приклад коду до рефакторинґу ("магічні числа"):
17. // Тимчасові дані для демонстрації
18. const user = { role: 3 };
19. const session = { duration: 90000 };


20. console.log("--- Приклад 2 (ДО): Магічні числа ---");
21. if (user.role === 3) {
22.   // Незрозуміло, що означає 3 без контексту
23.   console.log("Користувач має роль 3");
24. }
25. if (session.duration > 86400) {
26.   // 86400 — теж «магічне» число без пояснення
27.   console.log("Сесія триває довше 86400");
28. }


В.4 Приклад коду після рефакторинґу (використання констант): 
29. console.log("--- Приклад 2 (ПІСЛЯ): Константи ---");
30. const ADMIN_ROLE = 3;
31. const SECONDS_IN_A_DAY = 86400;


32. if (user.role === ADMIN_ROLE) {
33.   // Код став зрозумілішим: тепер видно, що це роль адміністратора
34.   console.log("Користувач має роль Адміна");
35. }
36. if (session.duration > SECONDS_IN_A_DAY) {
37.   // Константа пояснює значення — це доба у секундах
38.   console.log("Сесія триває довше одного дня");
39. }


В.5 Приклад коду до рефакторинґу ("пастка булевих значень"):
40. console.log("--- Приклад 3 (ДО): Пастка булевих значень ---");


41. // Функція з великою кількістю булевих аргументів
42. function createUser_before(
43.   name,
44.   pass,
45.   isAdmin,
46.   isTemp,
47.   isActive
48. ) {
49.   console.log(`Створено (до): ${name}, admin: ${isAdmin}`);
50.   // Код складно читати, бо важко зрозуміти, що означає кожен параметр
51. }


52. // Виклик: значення неочевидні
53. createUser_before("ivan", "pass123", true, false, true);


В.6 Приклад коду після рефакторинґу (використання об'єкта):
54. console.log("--- Приклад 3 (ПІСЛЯ): Об'єкт налаштувань ---");


55. // Тепер функція приймає об’єкт — це зручніше і читабельніше
56. function createUser_after({
57.   name,
58.   password,
59.   isAdmin = false,
60. }) {
61.   console.log(`Створено (після): ${name}, admin: ${isAdmin}`);
62.   // Параметри тепер мають очевидні назви
63. }


64. // Виклик став самодокументованим
65. createUser_after({
66.   name: "ivan",
67.   password: "pass123",
68.   isAdmin: true,
69. });


70. // Можна викликати й без необов’язкових параметрів
71. createUser_after({
72.   name: "petro",
73. });