МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ




ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмна інженерія»








ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення (Replace Data Value with Object, Encapsulate Collection, Encapsulate Collection)»














Виконав:                                          Прийняв:
ст. гр. ПЗПІ-23-8                             Старший викладач каф. ПІ Сокорчук І. П.
Козлов С. О. 








Харків 2025
1.1 Історія змін


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	10.11.2025
	0.1
	Створено структуру звіту, додано розділ Мета роботи.
	2
	10.11.2025
	0.2
	Додано розділ Хід роботи з аналізом трьох методів рефакторингу.
	3
	10.11.2025
	0.3
	Оформлено приклади програмного коду до та після у Додатку В.
	4
	10.11.2025
	1.0
	Додано Додатки А (хронометраж) та Б (слайди), фінальна вичитка.
	



1.2 Мета роботи
Метою даної роботи є вивчення та практичне застосування основних методів рефакторингу програмного коду, описаних у книзі Мартіна Фаулера.


1.3 Хід роботи


1.3.1  Загальне поняття рефакторингу
Рефакторинг – це дисциплінована техніка зміни внутрішньої структури програмного коду, яка не впливає на його зовнішню поведінку. Головна мета рефакторингу — не додавати нову функціональність, а покращувати якість існуючого коду. Це контрольований процес «прибирання» коду, спрямований на боротьбу з технічним боргом, покращення читабельності та спрощення подальшої підтримки й розширення.
У рамках даної роботи було обрано та проаналізовано три потужні методи рефакторингу з книги Мартіна Фаулера.


1.3.2  Метод 1: Replace Data Value with Object (Заміна значення даних об'єктом)
* Опис проблеми: Цей метод застосовується, коли просте поле (наприклад, string або number) починає накопичувати пов'язану з ним логіку. У  проєкті клас Task мав поле priority: string зі значеннями "High", "Medium", "Low". Проблема полягала в тому, що для визначення, наприклад, кольору пріоритету або його індексу сортування, доводилося писати логіку в інших місцях програми, розмазуючи її та порушуючи інкапсуляцію.
* Код до рефакторингу: Як видно на слайді 5 , клас Task містив лише рядок priority. Логіка визначення кольору була винесена в окрему функцію getPriorityColor(task: Task) , яка знаходилась у компоненті UI.
* Код після рефакторингу: Було створено новий клас Priority. Цей клас інкапсулював у собі як саме значення ("High"), так і всю пов'язану логіку (метод getColor()) . Поле priority у класі Task було замінене з string на об'єкт Priority.
* Переваги:
   1. Інкапсуляція: Вся логіка, пов'язана з пріоритетом, тепер зібрана в одному місці.
   2. Розширюваність: Можна легко додати новий метод getSortIndex() до класу Priority, не змінюючи Task.
   3. Чистота: Код став більш об'єктно-орієнтованим та типобезпечним.
1.3.3 Метод 2: Encapsulate Collection (Інкапсуляція колекції)
* Опис проблеми: Цей метод вирішує проблему, коли клас надає публічний доступ до внутрішньої колекції (наприклад, масиву). У проєкті клас Course мав публічне поле students: string[]. Це дозволяло будь-якому зовнішньому коду напряму маніпулювати масивом, наприклад, виконати myCourse.students = [] і таким чином зламати стан об'єкта. Клас втрачав контроль над своїми даними і не міг додати логіку валідації (наприклад, ліміт на кількість студентів).
* Код до рефакторингу: На слайді 9 видно public students: string[] = [] та приклади прямого неконтрольованого доступу .
* Код після рефакторингу: Поле students було зроблено приватним (private _students). Натомість було надано два публічні методи: addStudent(name: string) та getStudents(): readonly string[]. Метод addStudent тепер може містити логіку валідації (наприклад, перевірку на ліміт студентів). Метод getStudents повертає лише копію масиву або масив readonly, що не дозволяє зовнішньому коду змінювати внутрішній стан.
* Переваги:
   1. Контроль стану: Клас Course тепер повністю контролює свій стан та може інтегрувати бізнес-логіку валідації.
   2. Захист даних: Зовнішній код не може випадково чи навмисно зламати внутрішні дані.
   3. Гнучкість: Ми можемо змінити внутрішню реалізацію (наприклад, Array на Set) без впливу на публічний API.
1.3.4 Метод 3: Replace Conditional with Polymorphism (Заміна умовної логіки поліморфізмом)
* Опис проблеми: Це один з найпотужніших методів, що застосовується за наявності великої умовної конструкції (switch або if-else), яка перевіряє "тип" об'єкта і виконує різну логіку. У проєкті була функція calculatePayment(user), яка перевіряла user.type ("Admin", "Editor", "Viewer"). Це є класичним порушенням Принципу Відкритості/Закритості: при додаванні нового типу "Moderator" довелося б лізти і модифікувати цей switch, ризикуючи зламати існуючий код.
* Код до рефакторингу: На слайді 12 показано інтерфейс User з полем type та громіздку функцію calculatePayment з логікою switch .
* Код після рефакторингу: Логіка switch була усунена. Було створено abstract class User з абстрактним методом getPayment(). Кожен тип користувача (Admin, Editor, Viewer) став окремим класом, що наслідує User та реалізує власний, унікальний метод getPayment() . Тепер клієнтський код просто викликає user.getPayment(), а поліморфізм автоматично обирає правильну реалізацію.
* Переваги:
   1. Принцип Відкритості/Закритості: Код відкритий для розширення (можна додати class Moderator extends User), але закритий для модифікації (старі класи чіпати не потрібно).
   2. Інкапсуляція: Логіка розрахунку тепер знаходиться там, де їй місце — всередині кожного конкретного класу користувача.
   3. Легке тестування: Кожен клас типу користувача можна тестувати окремо та ізольовано.


1.3.5 Інструменти для рефакторингу
Варто зазначити, що багато методів рефакторингу автоматизовані у сучасних середовищах розробки (IDE). Такі інструменти, як JetBrains WebStorm, Rider або Visual Studio Code, мають вбудовані функції, що дозволяють безпечно Виділити метод, Інкапсулювати поле чи Перемістити метод, значно знижуючи ризик помилки під час ручного рефакторингу .






1.4 Висновки
* Було розглянуто фундаментальне поняття рефакторингу як постійного процесу підтримки «гігієни» коду, а не як разової дії.
* Було проаналізовано три конкретні методи: «Replace Data Value with Object», «Encapsulate Collection» та «Replace Conditional with Polymorphism».
* Було продемонстровано, як ці методи трансформують код від процедурного стилю (змішана логіка, switch, прямий доступ до даних) до більш надійного, об'єктно-орієнтованого дизайну (інкапсуляція, поліморфізм) .
* Отримано навички ідентифікації «кодових запахів» та застосування відповідних технік рефакторингу для покращення архітектури коду, його гнучкості, розширюваності та спрощення тестування.






1.5 Використані джерела
1. Фаулер М. Рефакторинг. Поліпшення проектування існуючого коду. 2-е вид. Addison-Wesley Professional, 2018.
2. TypeScript: JavaScript With Syntax For Types. [Online]. Available: {https://www.typescriptlang.org/docs/}
3. ДСТУ 3008:2015. Інформація та документація. Звіти у сфері науки і техніки. Структура та правила оформлювання.






Додаток А
Відеозапис доповіді розміщено на платформі YouTube за посиланням:
https://youtu.be/bNOUL16bY7w


Хронологічний опис відеозапису:
* 00:00 — Вступ: Тема доповіді «Методи рефакторингу коду».
* 00:20 — Що таке рефакторинг? (Визначення, мета, технічний борг).
* 00:41 — Огляд трьох обраних методів (Replace Data Value with Object, Encapsulate Collection, Replace Conditional with Polymorphism).
* 00:55 — Метод 1: Replace Data Value with Object (Опис проблеми: priority: string).
* 01:35 — Метод 1: Код ДО (Аналіз "поганого" коду з string).
* 01:53 — Метод 1: Код ПІСЛЯ (Створення класу Priority, інкапсуляція логіки).
* 02:15 — Метод 1: Переваги (Інкапсуляція, розширюваність).
* 02:37 — Метод 2: Encapsulate Collection (Опис проблеми: публічний масив students).
* 03:13 — Метод 2: Код ДО і ПІСЛЯ (Перехід від public поля до private з методами add/get).
* 03:47 — Метод 2: Переваги (Контроль стану, захист даних, гнучкість).
* 04:15 — Метод 3: Replace Conditional with Polymorphism (Опис проблеми: switch та порушення Принципу Відкритості/Закритості).
* 04:55 — Метод 3: Код ДО (Аналіз "поганого" коду з switch).
* 05:22 — Метод 3: Код ПІСЛЯ (Створення абстрактного класу та поліморфних підкласів).
* 05:50 — Метод 3: Переваги (Дотримання OCP, легке тестування).
* 06:25 — Інструменти (Роль IDE в автоматизації рефакторингу).
* 06:47 — Висновки (Рефакторинг як постійний процес, перехід до ООП).)






Додаток Б
Слайди презентації
  

Рисунок Б.1 — Титульний слайд: Методи рефакторингу коду


  

Рисунок Б.2 — Визначення та мета рефакторингу 




  

Рисунок Б.3 — Огляд трьох обраних методів рефакторингу


  
 
Рисунок Б.4 — Метод 1: Опис проблеми "Replace Data Value with Object" 


  

Рисунок Б.5 — Метод 1: Приклад коду ДО рефакторингу 


  

Рисунок Б.6 — Метод 1: Приклад коду ПІСЛЯ рефакторингу 
  

Рисунок Б.7 — Метод 1: Переваги (Інкапсуляція, Розширюваність) 


  

Рисунок Б.8 — Метод 2: Опис проблеми "Encapsulate Collection"


  
 
Рисунок Б.9 — Метод 2: Приклад коду ДО та ПІСЛЯ рефакторингу


  

Рисунок Б.10 — Метод 2: Переваги (Контроль стану, Захист даних, Гнучкість) 


  

Рисунок Б.11 — Метод 3: Опис проблеми "Replace Conditional with Polymorphism" 


  

Рисунок Б.12 — Метод 3: Приклад коду ДО рефакторингу (switch) 


  

Рисунок Б.13 — Метод 3: Приклад коду ПІСЛЯ рефакторингу (Поліморфізм) 


  

Рисунок Б.14 — Метод 3: Переваги (Принцип Відкритості/Закритості, Легке тестування) 
  

Рисунок Б.15 — Огляд інструментів для автоматизації рефакторингу 


  

Рисунок Б.16 — Загальні висновки роботи


































Додаток В
Програмний код
https://github.com/NureKozlovSerhii/ark-pzpi-23-8-kozlov-serhii/blob/main/Pract2/apz-pzpi-23-8-kozlov-serhii-pract2/code-examples-refactoring-methods.ts


В.1 Приклад коду до рефакторинґу (Метод 1: string замість об'єкта):
1. // БУЛО (ПОГАНО):
2. class Task {
3.   title: string;
4.   priority: string; // "High", "Medium", "Low" 
5.
6.   constructor(title: string, priority: string) { 
7.     this.title = title;
8.     this.priority = priority; 
9.   }
10. }
11.
12. // Десь в іншому місці (UI компонент):
13. function getPriorityColor(task: Task): string {
14.   if (task.priority === "High") return "#FF0000"; 
15.   if (task.priority === "Medium") return "#FFA500"; 
16.   return "#00FF00"; 
17. }


В.2 Приклад коду після рефакторинґу (Метод 1: Використання об'єкта Priority)
1. // СТАЛО (ДОБРЕ):
2. class Priority {
3.   private value: string;
4.   constructor(value: string) { this.value = value; } 
5.
6.   toString(): string { return this.value; } 
7.   
8.   getColor(): string { 
9.     if (this.value === "High") return "#FF0000";
10.    if (this.value === "Medium") return "#FFA500"; 
11.    return "#00FF00"; 
12.   }
13. }
14.
15. class Task {
16.   title: string;
17.   priority: Priority; // Тепер це об'єкт! 
18.   constructor(title: string, priority: Priority) { 
19.     this.title = title;
20.     this.priority = priority; 
21.   }
22. }




В.3 Приклад коду до рефакторинґу (Метод 2: Публічна колекція)
1. // БУЛО (ПОГАНО)
2. class Course {
3.   public students: string[] = [];
4. }
5.
6. const oop = new Course();
7. oop.students.push("Ivan"); // Прямий доступ 
8. oop.students = []; // Повністю зламали стан класу 


В.4 Приклад коду після рефакторинґу (Метод 2: Інкапсульована колекція)
1. // СТАЛО (ДОБРЕ):
2. class Course {
3.   private _students: string[] = [];
4.   
5.   public addStudent(name: string) {
6.     if (this._students.length >= 30) {
7.       throw new Error("Курс заповнений");
8.     }
9.     this._students.push(name);
10.   }
11.
12.   // Повертаємо копію або 'readonly' масив
13.   public getStudents(): readonly string[] {
14.     return [...this._students]; 
15.   }
16. }
17. const oop = new Course();
18. oop.addStudent("Ivan"); // Контрольований доступ
19. // oop._students = []; // ПОМИЛКА КОМПІЛЯЦІЇ


В.5 Приклад коду до рефакторинґу (Метод 3: Умовна логіка switch)
1. // БУЛО (ПОГАНО):
2. interface User {
3.   type: 'Admin' | 'Editor' | 'Viewer'; 
4.   baseRate: number;
5. }
6.
7. function calculatePayment(user: User): number { 
8.   switch (user.type) { 
9.     case 'Admin':
10.      return user.baseRate * 1.5; 
11.    case 'Editor':
12.      return user.baseRate * 1.2; 
13.    case 'Viewer':
14.      return user.baseRate * 1.0; 
15.    default:
16.      throw new Error("Unknown user type"); 
17.  }
18. }






В.6 Приклад коду після рефакторинґу (Метод 3: Поліморфізм)
1. // СТАЛО (ДОБРЕ):
2. abstract class User {
3.   baseRate: number;
4.   abstract getPayment(): number; 
5. }
6.
7. class Admin extends User {
8.   getPayment(): number { return this.baseRate * 1.5; } 
9. }
10. class Editor extends User {
11.   getPayment(): number { return this.baseRate * 1.2; } 
12. }
13. class Viewer extends User {
14.   getPayment(): number { return this.baseRate * 1.0; } 
15. }
16.
17. // Тепер нам не потрібен 'switch'
18. // const payment = user.getPayment();